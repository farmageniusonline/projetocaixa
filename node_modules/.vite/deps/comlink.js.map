{
  "version": 3,
  "sources": ["../../comlink/src/comlink.ts"],
  "sourcesContent": ["/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\nimport {\r\n  Endpoint,\r\n  EventSource,\r\n  Message,\r\n  MessageType,\r\n  PostMessageWithOrigin,\r\n  WireValue,\r\n  WireValueType,\r\n} from \"./protocol\";\r\nexport type { Endpoint };\r\n\r\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\r\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\r\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nexport const finalizer = Symbol(\"Comlink.finalizer\");\r\n\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\n\r\n/**\r\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\r\n * Can also be implemented by classes.\r\n */\r\nexport interface ProxyMarked {\r\n  [proxyMarker]: true;\r\n}\r\n\r\n/**\r\n * Takes a type and wraps it in a Promise, if it not already is one.\r\n * This is to avoid `Promise<Promise<T>>`.\r\n *\r\n * This is the inverse of `Unpromisify<T>`.\r\n */\r\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\r\n/**\r\n * Takes a type that may be Promise and unwraps the Promise type.\r\n * If `P` is not a Promise, it returns `P`.\r\n *\r\n * This is the inverse of `Promisify<T>`.\r\n */\r\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\r\n\r\n/**\r\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\r\n *\r\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\r\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\r\n */\r\ntype RemoteProperty<T> =\r\n  // If the value is a method, comlink will proxy it automatically.\r\n  // Objects are only proxied if they are marked to be proxied.\r\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\r\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\r\n\r\n/**\r\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\r\n * argument) and returns the type that the local thread has to supply.\r\n *\r\n * This is the inverse of `RemoteProperty<T>`.\r\n *\r\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\r\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\r\n */\r\ntype LocalProperty<T> = T extends Function | ProxyMarked\r\n  ? Local<T>\r\n  : Unpromisify<T>;\r\n\r\n/**\r\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\r\n */\r\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\r\n/**\r\n * Inverse of `ProxyOrClone<T>`.\r\n */\r\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\r\n  ? Local<T>\r\n  : T;\r\n\r\n/**\r\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\r\n * when proxied with `Comlink.proxy()`.\r\n *\r\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\r\n *\r\n * @template T The raw type of a remote object as seen in the other thread.\r\n */\r\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\r\n/**\r\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\r\n * argument) and returns the type that the local thread has to supply.\r\n *\r\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\r\n *\r\n * This is the inverse of `RemoteObject<T>`.\r\n *\r\n * @template T The type of a proxied object.\r\n */\r\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\r\n\r\n/**\r\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\r\n */\r\nexport interface ProxyMethods {\r\n  [createEndpoint]: () => Promise<MessagePort>;\r\n  [releaseProxy]: () => void;\r\n}\r\n\r\n/**\r\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\r\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\r\n */\r\nexport type Remote<T> =\r\n  // Handle properties\r\n  RemoteObject<T> &\r\n    // Handle call signature (if present)\r\n    (T extends (...args: infer TArguments) => infer TReturn\r\n      ? (\r\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\r\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\r\n      : unknown) &\r\n    // Handle construct signature (if present)\r\n    // The return of construct signatures is always proxied (whether marked or not)\r\n    (T extends { new (...args: infer TArguments): infer TInstance }\r\n      ? {\r\n          new (\r\n            ...args: {\r\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\r\n            }\r\n          ): Promisify<Remote<TInstance>>;\r\n        }\r\n      : unknown) &\r\n    // Include additional special comlink methods available on the proxy.\r\n    ProxyMethods;\r\n\r\n/**\r\n * Expresses that a type can be either a sync or async.\r\n */\r\ntype MaybePromise<T> = Promise<T> | T;\r\n\r\n/**\r\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\r\n * passed in as a function argument) and returns the type the local thread has to supply.\r\n *\r\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\r\n */\r\nexport type Local<T> =\r\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\r\n  Omit<LocalObject<T>, keyof ProxyMethods> &\r\n    // Handle call signatures (if present)\r\n    (T extends (...args: infer TArguments) => infer TReturn\r\n      ? (\r\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\r\n        ) => // The raw function could either be sync or async, but is always proxied automatically\r\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\r\n      : unknown) &\r\n    // Handle construct signature (if present)\r\n    // The return of construct signatures is always proxied (whether marked or not)\r\n    (T extends { new (...args: infer TArguments): infer TInstance }\r\n      ? {\r\n          new (\r\n            ...args: {\r\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\r\n            }\r\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\r\n          MaybePromise<Local<Unpromisify<TInstance>>>;\r\n        }\r\n      : unknown);\r\n\r\nconst isObject = (val: unknown): val is object =>\r\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n\r\n/**\r\n * Customizes the serialization of certain values as determined by `canHandle()`.\r\n *\r\n * @template T The input type being handled by this transfer handler.\r\n * @template S The serialized type sent over the wire.\r\n */\r\nexport interface TransferHandler<T, S> {\r\n  /**\r\n   * Gets called for every value to determine whether this transfer handler\r\n   * should serialize the value, which includes checking that it is of the right\r\n   * type (but can perform checks beyond that as well).\r\n   */\r\n  canHandle(value: unknown): value is T;\r\n\r\n  /**\r\n   * Gets called with the value if `canHandle()` returned `true` to produce a\r\n   * value that can be sent in a message, consisting of structured-cloneable\r\n   * values and/or transferrable objects.\r\n   */\r\n  serialize(value: T): [S, Transferable[]];\r\n\r\n  /**\r\n   * Gets called to deserialize an incoming value that was serialized in the\r\n   * other thread with this transfer handler (known through the name it was\r\n   * registered under).\r\n   */\r\n  deserialize(value: S): T;\r\n}\r\n\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\r\n  canHandle: (val): val is ProxyMarked =>\r\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\r\n  serialize(obj) {\r\n    const { port1, port2 } = new MessageChannel();\r\n    expose(obj, port1);\r\n    return [port2, [port2]];\r\n  },\r\n  deserialize(port) {\r\n    port.start();\r\n    return wrap(port);\r\n  },\r\n};\r\n\r\ninterface ThrownValue {\r\n  [throwMarker]: unknown; // just needs to be present\r\n  value: unknown;\r\n}\r\ntype SerializedThrownValue =\r\n  | { isError: true; value: Error }\r\n  | { isError: false; value: unknown };\r\ntype PendingListenersMap = Map<\r\n  string,\r\n  (value: WireValue | PromiseLike<WireValue>) => void\r\n>;\r\n\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler: TransferHandler<\r\n  ThrownValue,\r\n  SerializedThrownValue\r\n> = {\r\n  canHandle: (value): value is ThrownValue =>\r\n    isObject(value) && throwMarker in value,\r\n  serialize({ value }) {\r\n    let serialized: SerializedThrownValue;\r\n    if (value instanceof Error) {\r\n      serialized = {\r\n        isError: true,\r\n        value: {\r\n          message: value.message,\r\n          name: value.name,\r\n          stack: value.stack,\r\n        },\r\n      };\r\n    } else {\r\n      serialized = { isError: false, value };\r\n    }\r\n    return [serialized, []];\r\n  },\r\n  deserialize(serialized) {\r\n    if (serialized.isError) {\r\n      throw Object.assign(\r\n        new Error(serialized.value.message),\r\n        serialized.value\r\n      );\r\n    }\r\n    throw serialized.value;\r\n  },\r\n};\r\n\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nexport const transferHandlers = new Map<\r\n  string,\r\n  TransferHandler<unknown, unknown>\r\n>([\r\n  [\"proxy\", proxyTransferHandler],\r\n  [\"throw\", throwTransferHandler],\r\n]);\r\n\r\nfunction isAllowedOrigin(\r\n  allowedOrigins: (string | RegExp)[],\r\n  origin: string\r\n): boolean {\r\n  for (const allowedOrigin of allowedOrigins) {\r\n    if (origin === allowedOrigin || allowedOrigin === \"*\") {\r\n      return true;\r\n    }\r\n    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function expose(\r\n  obj: any,\r\n  ep: Endpoint = globalThis as any,\r\n  allowedOrigins: (string | RegExp)[] = [\"*\"]\r\n) {\r\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\r\n    if (!ev || !ev.data) {\r\n      return;\r\n    }\r\n    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\r\n      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\r\n      return;\r\n    }\r\n    const { id, type, path } = {\r\n      path: [] as string[],\r\n      ...(ev.data as Message),\r\n    };\r\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n    let returnValue;\r\n    try {\r\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n      switch (type) {\r\n        case MessageType.GET:\r\n          {\r\n            returnValue = rawValue;\r\n          }\r\n          break;\r\n        case MessageType.SET:\r\n          {\r\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n            returnValue = true;\r\n          }\r\n          break;\r\n        case MessageType.APPLY:\r\n          {\r\n            returnValue = rawValue.apply(parent, argumentList);\r\n          }\r\n          break;\r\n        case MessageType.CONSTRUCT:\r\n          {\r\n            const value = new rawValue(...argumentList);\r\n            returnValue = proxy(value);\r\n          }\r\n          break;\r\n        case MessageType.ENDPOINT:\r\n          {\r\n            const { port1, port2 } = new MessageChannel();\r\n            expose(obj, port2);\r\n            returnValue = transfer(port1, [port1]);\r\n          }\r\n          break;\r\n        case MessageType.RELEASE:\r\n          {\r\n            returnValue = undefined;\r\n          }\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n    } catch (value) {\r\n      returnValue = { value, [throwMarker]: 0 };\r\n    }\r\n    Promise.resolve(returnValue)\r\n      .catch((value) => {\r\n        return { value, [throwMarker]: 0 };\r\n      })\r\n      .then((returnValue) => {\r\n        const [wireValue, transferables] = toWireValue(returnValue);\r\n        ep.postMessage({ ...wireValue, id }, transferables);\r\n        if (type === MessageType.RELEASE) {\r\n          // detach and deactive after sending release response above.\r\n          ep.removeEventListener(\"message\", callback as any);\r\n          closeEndPoint(ep);\r\n          if (finalizer in obj && typeof obj[finalizer] === \"function\") {\r\n            obj[finalizer]();\r\n          }\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        // Send Serialization Error To Caller\r\n        const [wireValue, transferables] = toWireValue({\r\n          value: new TypeError(\"Unserializable return value\"),\r\n          [throwMarker]: 0,\r\n        });\r\n        ep.postMessage({ ...wireValue, id }, transferables);\r\n      });\r\n  } as any);\r\n  if (ep.start) {\r\n    ep.start();\r\n  }\r\n}\r\n\r\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\r\n  return endpoint.constructor.name === \"MessagePort\";\r\n}\r\n\r\nfunction closeEndPoint(endpoint: Endpoint) {\r\n  if (isMessagePort(endpoint)) endpoint.close();\r\n}\r\n\r\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\r\n  const pendingListeners : PendingListenersMap = new Map();\r\n\r\n  ep.addEventListener(\"message\", function handleMessage(ev: Event) {\r\n    const { data } = ev as MessageEvent;\r\n    if (!data || !data.id) {\r\n      return;\r\n    }\r\n    const resolver = pendingListeners.get(data.id);\r\n    if (!resolver) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      resolver(data);\r\n    } finally {\r\n      pendingListeners.delete(data.id);\r\n    }\r\n  });\r\n\r\n  return createProxy<T>(ep, pendingListeners, [], target) as any;\r\n}\r\n\r\nfunction throwIfProxyReleased(isReleased: boolean) {\r\n  if (isReleased) {\r\n    throw new Error(\"Proxy has been released and is not useable\");\r\n  }\r\n}\r\n\r\nfunction releaseEndpoint(ep: Endpoint) {\r\n  return requestResponseMessage(ep, new Map(), {\r\n    type: MessageType.RELEASE,\r\n  }).then(() => {\r\n    closeEndPoint(ep);\r\n  });\r\n}\r\n\r\ninterface FinalizationRegistry<T> {\r\n  new (cb: (heldValue: T) => void): FinalizationRegistry<T>;\r\n  register(\r\n    weakItem: object,\r\n    heldValue: T,\r\n    unregisterToken?: object | undefined\r\n  ): void;\r\n  unregister(unregisterToken: object): void;\r\n}\r\ndeclare var FinalizationRegistry: FinalizationRegistry<Endpoint>;\r\n\r\nconst proxyCounter = new WeakMap<Endpoint, number>();\r\nconst proxyFinalizers =\r\n  \"FinalizationRegistry\" in globalThis &&\r\n  new FinalizationRegistry((ep: Endpoint) => {\r\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\r\n    proxyCounter.set(ep, newCount);\r\n    if (newCount === 0) {\r\n      releaseEndpoint(ep);\r\n    }\r\n  });\r\n\r\nfunction registerProxy(proxy: object, ep: Endpoint) {\r\n  const newCount = (proxyCounter.get(ep) || 0) + 1;\r\n  proxyCounter.set(ep, newCount);\r\n  if (proxyFinalizers) {\r\n    proxyFinalizers.register(proxy, ep, proxy);\r\n  }\r\n}\r\n\r\nfunction unregisterProxy(proxy: object) {\r\n  if (proxyFinalizers) {\r\n    proxyFinalizers.unregister(proxy);\r\n  }\r\n}\r\n\r\nfunction createProxy<T>(\r\n  ep: Endpoint,\r\n  pendingListeners: PendingListenersMap,\r\n  path: (string | number | symbol)[] = [],\r\n  target: object = function () {}\r\n): Remote<T> {\r\n  let isProxyReleased = false;\r\n  const proxy = new Proxy(target, {\r\n    get(_target, prop) {\r\n      throwIfProxyReleased(isProxyReleased);\r\n      if (prop === releaseProxy) {\r\n        return () => {\r\n          unregisterProxy(proxy);\r\n          releaseEndpoint(ep);\r\n          pendingListeners.clear();\r\n          isProxyReleased = true;\r\n        };\r\n      }\r\n      if (prop === \"then\") {\r\n        if (path.length === 0) {\r\n          return { then: () => proxy };\r\n        }\r\n        const r = requestResponseMessage(ep, pendingListeners, {\r\n          type: MessageType.GET,\r\n          path: path.map((p) => p.toString()),\r\n        }).then(fromWireValue);\r\n        return r.then.bind(r);\r\n      }\r\n      return createProxy(ep, pendingListeners, [...path, prop]);\r\n    },\r\n    set(_target, prop, rawValue) {\r\n      throwIfProxyReleased(isProxyReleased);\r\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n      const [value, transferables] = toWireValue(rawValue);\r\n      return requestResponseMessage(\r\n        ep,\r\n        pendingListeners,\r\n        {\r\n          type: MessageType.SET,\r\n          path: [...path, prop].map((p) => p.toString()),\r\n          value,\r\n        },\r\n        transferables\r\n      ).then(fromWireValue) as any;\r\n    },\r\n    apply(_target, _thisArg, rawArgumentList) {\r\n      throwIfProxyReleased(isProxyReleased);\r\n      const last = path[path.length - 1];\r\n      if ((last as any) === createEndpoint) {\r\n        return requestResponseMessage(ep, pendingListeners, {\r\n          type: MessageType.ENDPOINT,\r\n        }).then(fromWireValue);\r\n      }\r\n      // We just pretend that `bind()` didn’t happen.\r\n      if (last === \"bind\") {\r\n        return createProxy(ep, pendingListeners, path.slice(0, -1));\r\n      }\r\n      const [argumentList, transferables] = processArguments(rawArgumentList);\r\n      return requestResponseMessage(\r\n        ep,\r\n        pendingListeners,\r\n        {\r\n          type: MessageType.APPLY,\r\n          path: path.map((p) => p.toString()),\r\n          argumentList,\r\n        },\r\n        transferables\r\n      ).then(fromWireValue);\r\n    },\r\n    construct(_target, rawArgumentList) {\r\n      throwIfProxyReleased(isProxyReleased);\r\n      const [argumentList, transferables] = processArguments(rawArgumentList);\r\n      return requestResponseMessage(\r\n        ep,\r\n        pendingListeners,\r\n        {\r\n          type: MessageType.CONSTRUCT,\r\n          path: path.map((p) => p.toString()),\r\n          argumentList,\r\n        },\r\n        transferables\r\n      ).then(fromWireValue);\r\n    },\r\n  });\r\n  registerProxy(proxy, ep);\r\n  return proxy as any;\r\n}\r\n\r\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\r\n  return Array.prototype.concat.apply([], arr);\r\n}\r\n\r\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\r\n  const processed = argumentList.map(toWireValue);\r\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\n\r\nconst transferCache = new WeakMap<any, Transferable[]>();\r\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\r\n  transferCache.set(obj, transfers);\r\n  return obj;\r\n}\r\n\r\nexport function proxy<T extends {}>(obj: T): T & ProxyMarked {\r\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\r\n}\r\n\r\nexport function windowEndpoint(\r\n  w: PostMessageWithOrigin,\r\n  context: EventSource = globalThis,\r\n  targetOrigin = \"*\"\r\n): Endpoint {\r\n  return {\r\n    postMessage: (msg: any, transferables: Transferable[]) =>\r\n      w.postMessage(msg, targetOrigin, transferables),\r\n    addEventListener: context.addEventListener.bind(context),\r\n    removeEventListener: context.removeEventListener.bind(context),\r\n  };\r\n}\r\n\r\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\r\n  for (const [name, handler] of transferHandlers) {\r\n    if (handler.canHandle(value)) {\r\n      const [serializedValue, transferables] = handler.serialize(value);\r\n      return [\r\n        {\r\n          type: WireValueType.HANDLER,\r\n          name,\r\n          value: serializedValue,\r\n        },\r\n        transferables,\r\n      ];\r\n    }\r\n  }\r\n  return [\r\n    {\r\n      type: WireValueType.RAW,\r\n      value,\r\n    },\r\n    transferCache.get(value) || [],\r\n  ];\r\n}\r\n\r\nfunction fromWireValue(value: WireValue): any {\r\n  switch (value.type) {\r\n    case WireValueType.HANDLER:\r\n      return transferHandlers.get(value.name)!.deserialize(value.value);\r\n    case WireValueType.RAW:\r\n      return value.value;\r\n  }\r\n}\r\n\r\nfunction requestResponseMessage(\r\n  ep: Endpoint,\r\n  pendingListeners: PendingListenersMap,\r\n  msg: Message,\r\n  transfers?: Transferable[]\r\n): Promise<WireValue> {\r\n  return new Promise((resolve) => {\r\n    const id = generateUUID();\r\n    pendingListeners.set(id, resolve);\r\n    if (ep.start) {\r\n      ep.start();\r\n    }\r\n    ep.postMessage({ id, ...msg }, transfers);\r\n});\r\n}\r\n\r\nfunction generateUUID(): string {\r\n  return new Array(4)\r\n    .fill(0)\r\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n    .join(\"-\");\r\n}\r\n"],
  "mappings": "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",
  "names": ["obj", "returnValue", "proxy"]
}
